Kort ordlista
  Scene/scen - En plats i handlingen.
  Actor/aktör - En karaktär i handlingen.
  Prop/rekvisita - En sak i handlingen.
  PlotBody - Actors och props. Ett interface så båda har en getLocation()-metod.
  PlotThing/SAPs - Scenes, actors och props.
  Agent - En karaktär i AI-algoritmen, innehåller en actor.

se.chalmers.plotgen

  PlotEngine
    Plotgens huvudklass. Ges en seed, så ser den till att en plotgraf och SAPs
    genereras utifrån den. SAPs genererar den själv, vilket i princip bara 
    innebär att den slumpar fram ett antal av varje sorts SAP (inom olika 
    intervall, som finns definierade i koden för tillfället) samt slumpar fram
    namn på dem med hjälp av NameGen. Plotgrafen genereras av en fristående 
    algoritm. Denna algoritm ser också till att placera ut actors på scener
    och props på scener och hos actors.
    
    Engine kan, utöver att returnera alla SAPs och plotgrafen, också hålla koll 
    på handlingens tillstånd. Då blir plotgrafen som en sorts state-machine. Ur 
    engine kan man få vilken nod man är på, samt vilka kanter (möjliga actions) 
    som går ut ur den. Man kan också välja att göra en av dessa actions, med
    takeAction-metoden. Då ändras aktiv plotnod till nästa i grafen. takeAction-
    metoden kastar en exception om man försöker göra en action som inte är 
    aktuell (jag är osäker på om det här är det vettigaste sättet att göra 
    detta på).
    
    Engine innehåller en main-metod, så att den ska kunna köras fristående. 
    För tillfället printar main-metoden helt enkelt ut grafen. För att den ska 
    vara fint fristående så kan man tänkbart göra så att den printar ut grafen 
    och SAPsen i JSON-format eller liknande, borde inte vara jättesvårt.
    
    Engine är annars tänkt att den ska gå utmärkt att använda från spelet och 
    att den då ska kunna hålla koll på handlingens tillstånd.

  ImpossibleActionException
    Den exception som kastas om man med engine försöker ta en action som inte 
    är aktuell.
  
  PlotGenerator
    En klass med bara statiska metoder. Min tanke var att plotgen-algoritmerna 
    ska ligga här. hardCodedAlgorithm() har sin logik här. Även 
    basicAIAlgorithm() finns här, men den kallar i princip bara direkt på en 
    utomstående metod. I vilket fall så finns alla algorithmer för plotgen 
    samlade här.
  
  PlotTest
    Ett test som skapar SAPs och en plotgraf med engine, printar ut allt 
    och sedan testar att hämta aktiv nod och möjliga actions, sedan tar en 
    action och hämtar nästa aktiva nod.

se.chalmers.plotgen.PlotData

  Klasser för alla fysiska saker som finns i en handling samt hur de 
  interagerar med varandra. Karaktärer, platser, saker och olika handlingar som 
  karaktärer kan göra. 

  PlotThing
    Överklassen för alla SAPs. Varje PlotThing har ett namn och en toString-
    metod som helt enkelt ser till att detta namn printas när man försöker 
    pritna PlotThingen.

  Scene
    En plats i en plot. Innehåller de actors och props som finns på platsen. 
    Dock ska man inte adda dessa till scenen, utan istället använder man 
    prop.setLocation(scene) samt actor.setLocation(scene), så ser de metoderna 
    till att de också addas till scenen.

  Actor
    En karaktär i en plot. Kan vara på en scene och äga flera props. Kan också 
    antingen leva eller vara död. Om man väljer att döda actorn så hamnar dess 
    props på den scene  där actorn dog. Man använder setLocation() för att 
    bestämma actorns plats, men man addar inte props till actorn, utan man 
    använder prop.setOwner(actor) när man vill att en viss ägare ska äga en 
    prop, så ser den metoden till att propsen också addas till actorn.
  
  Prop
    En sak i en plot. Kan vara på en scene eller ägas av en actor. När man vill 
    ändra detta så använder man setLocation() eller setOwner(). Propen är 
    antingen på en scene eller så ägs den av en actor, inte båda. 
  
  IPlotBody
    Ett interface för både actors och props, som säger att båda ska ha en 
    getLocation()- och en setLocation()-metod. Det underlättade basicAI-
    algoritmen lite.
  
  Action
    Beskriver alla de actions som en actor kan göra i spelet! I skrivande stund 
    finns KILL, TAKE, MEET, VISIT och GIVE. Actionen innehåller då vem som 
    gör den, vilken sorts action det är, och vem/vad den gör actionen på. De 
    olika varianterna beskrivs såhär:
      [Actor] [KILLS] [actor]
      [Actor] [TAKES] [prop]
      [Actor] [MEETS] [actor]
      [Actor] [VISITS] [scene]
      [Actor] [GIVES] [prop] (to) [actor]
    Dessa actions ska enkelt kunna tolkas av spelet. Det finns också en 
    toString-metod som gör att actions kan printas på ett mycket enkelt sätt.
  
  ActionTest
    Ett av de första test jag gjorde, urtypen för en plotgen-plot kan man 
    säga. :P Den skapar lite actors, props och actions och printar ut dem.

se.chalmers.plotgen.PlotGraph

  Här har vi den graf samt dess kanter och noder som abstrakt beskriver en 
  plot.
  
  Jag är lite osäker på hur vettig implementeringen är till viss grad... Till 
  att börja med är jag osäker på om det är vettigt att dela upp kanten och 
  noden. Jag tror nämligen inte att en nod någonsin kommer kunna nås av två 
  olika kanter. Jag känner mig lite dum, men jag insåg precis att ploten mer 
  specifikt bör beskrivas ett träd snarare än en graf. Detta kan nog påverka 
  implementeringen. 
  
  PlotGraph
    Tillsammans med SAPsen så beskriver plotgrafen handlingen. Den innehåller 
    noder, som är textsnuttar som ska presenteras för spelaren, som beskriver 
    handlingen (tänk det som manus för en berättare). Mellan noderna går 
    kanter, som i princip bara innehåller de actions som finns i PlotData-
    paketet. På det viset så är det dessa actions som för handlingen framåt. 
    Internt innehåller den en DirectedGraph, som jag har implementerat och som 
    ligger i plotgen.util.
    
    Plotgrafen har också koll på vilken nod som är startnoden och vilken nod 
    som är aktiv nod. Den kan också säga vilken nod som är aktiv, returnera 
    kanterna från den aktiva noden och man kan genom att ange en kant vandra 
    vidare i grafen och byta aktiv nod. 
    
    Grafer kan också printas på ett fint vis.
  
  PlotVertex
    Innehåller bara den sträng som beskriver handlingen vid den punkten.
  
  PlotEdge
    Innehåller bara den action som kan föra handlingen vidare vid den punkten.
    
se.chalmers.plotgen.util

  DirectedGraph
    En enkel implementering av en riktad graf. Innehåller de metoder jag har 
    bedömt vara nödvändiga till plotgrafen. Implementeringen är ganska lätt 
    att förstå från koden.
  
  Pair
    Är bara en kopia av Pair i roguelike.util. Ligger här också för att 
    plotgenpaketet ska kunna vara fristående.
    
se.chalmers.plotgen.BasicAIAlgorithm

  Här kommer vi till en lite köttigare bit av plotgenkoden. Här finns en enkel 
  AI-algoritm implementerad (knappt värd att kallas AI, antar jag). Utöver 
  själva algoritmen så är också agenter, operatorer och conditions 
  implementerade. Det kan verka onödigt att skilja på agenter och actors, 
  operatorer och actions. Jag tror dock att det viset som operatorer är 
  implementerade på är bättre för att en AI ska kunna resonera kring dem 
  (med betoning på _tror_, jag vet ju ärligt talat inte hur det blir i 
  slutändan...).
  
  Agent
    En agent innehåller sin motsvarande actor, samt vilka mål den vill uppnå. 
    De mål den vill uppnå representeras av conditions, och kan delas in i 
    sanna och falska mål. Sanna mål är helt enkelt conditions som agenten vill 
    ska vara sanna och falska mål conditions den vill ska vara falska.
    
  ICondition
    Interfacet för conditions. Har metoden get(), som returnerar om conditionen 
    är sann eller falsk, samt set(), där man kan sätta om conditionen ska vara 
    sann eller falsk. Detta gör man genom att kolla i SAPsen för att se om 
    påstående är sanna, samt ändra i SAPsen om man vill göra påståendena 
    sanna/falska.
    
  BelongsToCondition
    Innehåller en prop och en actor, och säger om propen tillhör actorn. 
    
  IsAtLocationCondition
    Innehåller en plotbody (prop eller actor) och en scene, och säger om 
    plotbodyn är på den scenen.
    
  LivesCondition
    Innehåller en actor och säger om actorn lever eller ej.
    
  SamePlaceCondition
    Innehåller en actor och en plotbody (hade kunnat vara två plotbodies, men 
    jag tro aldrig att man kommer vilja göra så) och säger om de är på samma 
    plats eller ej.
    
  Operator
    En operator är ungefär som en action för en agent. Den innehåller alla 
    conditions som måste vara sanna och alla conditions som måste vara falska 
    för att operatorn ska kunna göras. Den innehåller också alla conditions 
    som blir sanna och alla conditions som blir falska när operatorn görs.
    
    Innehåller också en action, för att huvudpersonens operatorer ska kunna 
    översättas till sådana när grafen ska skapas.
    
  Operators
    Detta är en klass med statiska metoder för att skapa olika sorters 
    operatorer. Alla dessa finns beskrivna i ett calcdokument i plotgenmappen 
    på Driven. Kolla där! Annars listar jag helt enkelt alla operatorer nedan: 
      killOperator(Actor self, Actor victim)
      takeOperator(Actor self, Prop prop)
      meetOperator(Actor self, Actor actor)
      visitOperator(Actor self, Scene targetLocation)
      giveOperator(Actor self, Actor recipient, Prop prop)

  BasicAIAlgorithm
    Här har vi en hel del rader kod! Denna klass innehåller till att börja med 
    en kommenterad TODO-lista, som helt enkelt råkade hamna där. Annars 
    innehåller den en mängd statiska metoder, där createPlot är den enda 
    publika. Jag tänker i alla fall att jag ska försöka beskriva alla dessa 
    metoder så bra som möjligt nedan.
    
    PlotGraph createPlot(scenes, actors, props, random)
      Random-instansen skickar vi med här för att vissa saker slumpas ibland 
      och genom att skicka med instansen kan algoritmen vara seed-baserad.
      
      Vi skapar agenter, vi slumpar fram mål åt dem och vi genererar alla 
      operatorer som agenterna kan göra. Sedan itererar vi igenom algoritmen 
      där agenterna får välja operatorer. När operatorerna är valda så försöker 
      varje agent utföra operatorn, om den inte har hindrats av någon annan 
      agents operator. Om det var huvudpersonen, så lägger vi till en kant och 
      en nod motsvarande operatorn i plotgrafen. När vi har itererat färdigt, 
      dvs när huvudpersonen har uppnått sitt mål (eller om huvudpersonen har 
      dött, så som det är nu), så returnerar vi plotgrafen.
      
      Lite TODO:
        - Huvudpersonen borde inte kunna dö (men samtidigt borde andra agenter 
          kunna ha det som mål).
        - Alla operatorer där huvudpersonen är med, även när huvudpersonen 
          egentligen bara är ett objekt, borde resultera i kanter i grafen.
      
      Vi testar att beskriva metoden i pseudokod:
      
        // Placera ut alla actors på scenes och props på scenes och hos actors
        placePlotBodies(scenes, actors, props, random);
        
        // Skapa en plotgraf, lägg till en första nod
        plotGraph = new PlotGraph();
        plotGraph.addRootVertex("This is a story");
        
        // Skapa agents av alla actors
        List<Agent> agents = createAgents(actors);
        
        // Lite godtyckligt, men huvudpersonen blir den sista i agentlistan
        mainAgent = agents.get(last);
        
        // Skapa mål åt alla agenter
        setAgentGoals(agents, scenes, actors, props, random);
        
        // Skapa alla operatorer
        // Operatorerna hålls i en hashmap, från agent till en lista av
        // de operatorer som den agenten kan göra
        HashMap<Agent, List<Operator>> operators = 
                                 createOperators(agents, scenes, actors, props)
        
        // Nu är allt förarbete gjort, nu ska vi låta agenterna välja 
        // operatorerna tills huvudpersonen når upp till sitt mål (eller 
        // tills huvudpersonen dör, för tillfället, vilket inte är helt rätt). 
        // För varje operator som huvudpersonen gör så skapar vi en ny kant 
        // och en ny nod i plotgrafen.
        // Och då detta är lite bökigare med loopar och liknande, så förklarar 
        // jag bara ganska grundligt.
        
        while (huvudpersonens mål ej är uppnådda och huvudpersonen lever):
        
          Ta bort agenter som har dött;
          
          // Välj operatorer åt alla agenter
          chooseOpsAlg(agents, operators, random);
          
          for (agent : agents):
            Gör den för agenten valda operatorn, ifall förutsättningarna 
            för att göra operatorn fortfarande har rätt värden;
            
            Om agenten var huvudpersonen, släng in en ny kant med den action 
            som operatorn motsvarar samt en ny nod i plotgrafen;
        
        return plotGraph;
        
      Så nu gäller det bara att förklara alla metoder som används i algoritmen!
    
    placePlotBodies(scenes, actors, props, random)
      Vi itererar genom alla actors och props tills de alla är utplacerade. 
      Actors ger vi en viss chans att de hamnar på olika scener, detsamma med 
      props. Props har också hög chans att hamna hos actors. Scenerna loopar 
      vi igenom tills vi är färdiga med våra actors och props, om det krävs så 
      börjar vi om från början på scenerna.
    
    chooseOpsAlg(agents, ops, random)
      Kolla igenom operatorer för agenten. Om alla conditions för operatorn är 
      uppfyllda, kolla hur många av de conditions operatorn uppfyller som 
      stämmer överens med agentens mål. Den operator som uppfyller flest 
      målconditions åt agenten är den agenten väljer. Om flera är lika bra, så 
      slumpar agenten en av dessa.
    
    createOperators(agents, scenes, actors, props)
      Lägg till alla operatorer för varje agent. Dvs, varje agent ska kunna 
      döda och träffa andra aktörer, varje agent ska kunna plocka alla props 
      osv.
      
      En idé: Här skulle man kunna göra en koll så att ingen lägger till en
      killOperator med huvudpersonen, utan göra så att den lägger till en 
      tryToKillOperator på huvudpersonen istället. På det viset kan 
      huvudpersonen inte dö, men folk kan ändå försöka uppnå det målet. 
      Kanske? :)
    
    createAgents(actors)
      Den här metoden skapar helt enkelt en agent för varje actor och slänger 
      in actorn i agenten.
    
    setAgentGoals(agents, scenes, actors, props, random)
      Här sätts mål för alla agenter. Det är enkelt gjort så att agenter 
      antingen kan få målet att de vill ha en specifik sak, eller att de vill 
      döda en specifik actor. Vi kollar specifikt att agenter inte får målet 
      att de ska få saker som de själva redan äger, eller att de ska döda sig 
      själva.
      
      Idé: För att spinna vidare på idén ovan, så borde man inte kunna få 
      målet att huvudpersonen ska dö, utan snarare att man ska ha försökt 
      döda honom. Kanske? :)
    
    checkConditions(beTrue, beFalse)
      Helt enkelt en metod som kollar om alla conditions som ska vara sanna 
      är det och om alla conditions som ska vara falska är det och sen 
      returnerar hur det ligger till.
    
  BasicAITest
    Innehåller ett par test med hårdkodade SAPs som använts för att se om 
    algoritmen alls fungerar.
